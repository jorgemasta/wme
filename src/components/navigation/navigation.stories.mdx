import { ArgsTable, Story, Canvas, Meta } from "@storybook/addon-docs";
import { useState } from 'react';
import { Navigation, NavNumber } from '..';

<Meta
  title="Navigation/Navigation"
  component={ Navigation }
  argTypes={{
    width: {
      name: 'width',
      description: 'Width of container for navigation. <br />Pass complete value, i.e. "500px" or "80%".',
      control: { type: 'text' },
      table: {
        defaultValue: { summary: 'auto'}
      },
    },
  }}
/>

export const screens = [
  {
    text: 'Screen 1',
    active: false,
    completed: true,
  },
  {
    text: 'Screen 2',
    active: true,
    completed: false,
  },
  {
    text: 'Screen 3',
    active: false,
    completed: false,
  },
  {
    text: 'Screen 4',
    active: false,
    completed: false,
  },
];

export const Template = (args) => {
  const [active, setActive] = useState(0)
  return (
    <Navigation {...args}>
      {
        screens.map((screen, i) => (
          <NavNumber
            number={i + 1}
            text={screen.text}
            onClick={() => setActive(i)}
            active={active === i}
            key={i}
            isComplete={screen.completed}
          />
        ))
      }
    </Navigation>
  );
}

# Navigation
Wrapper for the footer navigation in a wizard.

Steps are used to indicate an expected user flow and to let a user know which part of the flow they are currently on.

## Props
<ArgsTable story="." />

## Child Components
Navigation encompasses multiple "steps", which are each a `NavNumber` component.

`NavNumber` takes the following arguments:
- number (required)
- text (required)
- onClick (optional)
- active (required)
- isComplete (required)

## Notes
- In this particular example, the first step is hardcoded as "complete", so it shows with a checkbox.
However, you can use your own logic to determine the `isComplete` state on each step.

<Canvas>
  <Story
    name="Default"
    args={{ width: 'auto' }}
  >
  {Template.bind({})}
  </Story>
</Canvas>
